// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// entry_points_gl_2_0_autogen.cpp:
//   Defines the GL 2.0 entry points.

#include "libGL/entry_points_gl_2_0_autogen.h"

#include "libANGLE/Context.h"
#include "libANGLE/Context.inl.h"
#include "libANGLE/entry_points_utils.h"
#include "libANGLE/gl_enum_utils_autogen.h"
#include "libANGLE/validationEGL.h"
#include "libANGLE/validationES.h"
#include "libANGLE/validationES1.h"
#include "libANGLE/validationES2.h"
#include "libANGLE/validationES3.h"
#include "libANGLE/validationES31.h"
#include "libANGLE/validationESEXT.h"
#include "libANGLE/validationGL2_autogen.h"
#include "libGLESv2/global_state.h"

namespace gl
{
void GL_APIENTRY AttachShader(GLuint program, GLuint shader)
{
    EVENT("(GLuint program = %u, GLuint shader = %u)", program, shader);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateAttachShader(context, program, shader));
        if (isCallValid)
        {
            context->attachShader(program, shader);
        }
        ANGLE_CAPTURE(AttachShader, isCallValid, context, program, shader);
    }
}

void GL_APIENTRY BindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
    EVENT("(GLuint program = %u, GLuint index = %u, const GLchar *name = 0x%016" PRIxPTR ")",
          program, index, (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBindAttribLocation(context, program, index, name));
        if (isCallValid)
        {
            context->bindAttribLocation(program, index, name);
        }
        ANGLE_CAPTURE(BindAttribLocation, isCallValid, context, program, index, name);
    }
}

void GL_APIENTRY BlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
    EVENT("(GLenum modeRGB = %s, GLenum modeAlpha = %s)",
          GLenumToString(GLenumGroup::BlendEquationModeEXT, modeRGB),
          GLenumToString(GLenumGroup::BlendEquationModeEXT, modeAlpha));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBlendEquationSeparate(context, modeRGB, modeAlpha));
        if (isCallValid)
        {
            context->blendEquationSeparate(modeRGB, modeAlpha);
        }
        ANGLE_CAPTURE(BlendEquationSeparate, isCallValid, context, modeRGB, modeAlpha);
    }
}

void GL_APIENTRY CompileShader(GLuint shader)
{
    EVENT("(GLuint shader = %u)", shader);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateCompileShader(context, shader));
        if (isCallValid)
        {
            context->compileShader(shader);
        }
        ANGLE_CAPTURE(CompileShader, isCallValid, context, shader);
    }
}

GLuint GL_APIENTRY CreateProgram()
{
    EVENT("()");

    Context *context = GetValidGlobalContext();
    GLuint returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateCreateProgram(context));
        if (isCallValid)
        {
            returnValue = context->createProgram();
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::CreateProgram, GLuint>();
        }
        ANGLE_CAPTURE(CreateProgram, isCallValid, context, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::CreateProgram, GLuint>();
    }
    return returnValue;
}

GLuint GL_APIENTRY CreateShader(GLenum type)
{
    EVENT("(GLenum type = %s)", GLenumToString(GLenumGroup::ShaderType, type));

    Context *context = GetValidGlobalContext();
    GLuint returnValue;
    if (context)
    {
        ShaderType typePacked                         = FromGL<ShaderType>(type);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateCreateShader(context, typePacked));
        if (isCallValid)
        {
            returnValue = context->createShader(typePacked);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::CreateShader, GLuint>();
        }
        ANGLE_CAPTURE(CreateShader, isCallValid, context, typePacked, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::CreateShader, GLuint>();
    }
    return returnValue;
}

void GL_APIENTRY DeleteProgram(GLuint program)
{
    EVENT("(GLuint program = %u)", program);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateDeleteProgram(context, program));
        if (isCallValid)
        {
            context->deleteProgram(program);
        }
        ANGLE_CAPTURE(DeleteProgram, isCallValid, context, program);
    }
}

void GL_APIENTRY DeleteShader(GLuint shader)
{
    EVENT("(GLuint shader = %u)", shader);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateDeleteShader(context, shader));
        if (isCallValid)
        {
            context->deleteShader(shader);
        }
        ANGLE_CAPTURE(DeleteShader, isCallValid, context, shader);
    }
}

void GL_APIENTRY DetachShader(GLuint program, GLuint shader)
{
    EVENT("(GLuint program = %u, GLuint shader = %u)", program, shader);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateDetachShader(context, program, shader));
        if (isCallValid)
        {
            context->detachShader(program, shader);
        }
        ANGLE_CAPTURE(DetachShader, isCallValid, context, program, shader);
    }
}

void GL_APIENTRY DisableVertexAttribArray(GLuint index)
{
    EVENT("(GLuint index = %u)", index);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateDisableVertexAttribArray(context, index));
        if (isCallValid)
        {
            context->disableVertexAttribArray(index);
        }
        ANGLE_CAPTURE(DisableVertexAttribArray, isCallValid, context, index);
    }
}

void GL_APIENTRY DrawBuffers(GLsizei n, const GLenum *bufs)
{
    EVENT("(GLsizei n = %d, const GLenum *bufs = 0x%016" PRIxPTR ")", n, (uintptr_t)bufs);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateDrawBuffers(context, n, bufs));
        if (isCallValid)
        {
            context->drawBuffers(n, bufs);
        }
        ANGLE_CAPTURE(DrawBuffers, isCallValid, context, n, bufs);
    }
}

void GL_APIENTRY EnableVertexAttribArray(GLuint index)
{
    EVENT("(GLuint index = %u)", index);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateEnableVertexAttribArray(context, index));
        if (isCallValid)
        {
            context->enableVertexAttribArray(index);
        }
        ANGLE_CAPTURE(EnableVertexAttribArray, isCallValid, context, index);
    }
}

void GL_APIENTRY GetActiveAttrib(GLuint program,
                                 GLuint index,
                                 GLsizei bufSize,
                                 GLsizei *length,
                                 GLint *size,
                                 GLenum *type,
                                 GLchar *name)
{
    EVENT(
        "(GLuint program = %u, GLuint index = %u, GLsizei bufSize = %d, GLsizei *length = "
        "0x%016" PRIxPTR ", GLint *size = 0x%016" PRIxPTR ", GLenum *type = 0x%016" PRIxPTR
        ", GLchar *name = 0x%016" PRIxPTR ")",
        program, index, bufSize, (uintptr_t)length, (uintptr_t)size, (uintptr_t)type,
        (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateGetActiveAttrib(context, program, index, bufSize, length, size, type, name));
        if (isCallValid)
        {
            context->getActiveAttrib(program, index, bufSize, length, size, type, name);
        }
        ANGLE_CAPTURE(GetActiveAttrib, isCallValid, context, program, index, bufSize, length, size,
                      type, name);
    }
}

void GL_APIENTRY GetActiveUniform(GLuint program,
                                  GLuint index,
                                  GLsizei bufSize,
                                  GLsizei *length,
                                  GLint *size,
                                  GLenum *type,
                                  GLchar *name)
{
    EVENT(
        "(GLuint program = %u, GLuint index = %u, GLsizei bufSize = %d, GLsizei *length = "
        "0x%016" PRIxPTR ", GLint *size = 0x%016" PRIxPTR ", GLenum *type = 0x%016" PRIxPTR
        ", GLchar *name = 0x%016" PRIxPTR ")",
        program, index, bufSize, (uintptr_t)length, (uintptr_t)size, (uintptr_t)type,
        (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateGetActiveUniform(context, program, index, bufSize, length, size, type, name));
        if (isCallValid)
        {
            context->getActiveUniform(program, index, bufSize, length, size, type, name);
        }
        ANGLE_CAPTURE(GetActiveUniform, isCallValid, context, program, index, bufSize, length, size,
                      type, name);
    }
}

void GL_APIENTRY GetAttachedShaders(GLuint program,
                                    GLsizei maxCount,
                                    GLsizei *count,
                                    GLuint *shaders)
{
    EVENT("(GLuint program = %u, GLsizei maxCount = %d, GLsizei *count = 0x%016" PRIxPTR
          ", GLuint *shaders = 0x%016" PRIxPTR ")",
          program, maxCount, (uintptr_t)count, (uintptr_t)shaders);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetAttachedShaders(context, program, maxCount, count, shaders));
        if (isCallValid)
        {
            context->getAttachedShaders(program, maxCount, count, shaders);
        }
        ANGLE_CAPTURE(GetAttachedShaders, isCallValid, context, program, maxCount, count, shaders);
    }
}

GLint GL_APIENTRY GetAttribLocation(GLuint program, const GLchar *name)
{
    EVENT("(GLuint program = %u, const GLchar *name = 0x%016" PRIxPTR ")", program,
          (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    GLint returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetAttribLocation(context, program, name));
        if (isCallValid)
        {
            returnValue = context->getAttribLocation(program, name);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::GetAttribLocation, GLint>();
        }
        ANGLE_CAPTURE(GetAttribLocation, isCallValid, context, program, name, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::GetAttribLocation, GLint>();
    }
    return returnValue;
}

void GL_APIENTRY GetProgramInfoLog(GLuint program,
                                   GLsizei bufSize,
                                   GLsizei *length,
                                   GLchar *infoLog)
{
    EVENT("(GLuint program = %u, GLsizei bufSize = %d, GLsizei *length = 0x%016" PRIxPTR
          ", GLchar *infoLog = 0x%016" PRIxPTR ")",
          program, bufSize, (uintptr_t)length, (uintptr_t)infoLog);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetProgramInfoLog(context, program, bufSize, length, infoLog));
        if (isCallValid)
        {
            context->getProgramInfoLog(program, bufSize, length, infoLog);
        }
        ANGLE_CAPTURE(GetProgramInfoLog, isCallValid, context, program, bufSize, length, infoLog);
    }
}

void GL_APIENTRY GetProgramiv(GLuint program, GLenum pname, GLint *params)
{
    EVENT("(GLuint program = %u, GLenum pname = %s, GLint *params = 0x%016" PRIxPTR ")", program,
          GLenumToString(GLenumGroup::ProgramPropertyARB, pname), (uintptr_t)params);

    Context *context = GetGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetProgramiv(context, program, pname, params));
        if (isCallValid)
        {
            context->getProgramiv(program, pname, params);
        }
        ANGLE_CAPTURE(GetProgramiv, isCallValid, context, program, pname, params);
    }
}

void GL_APIENTRY GetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
    EVENT("(GLuint shader = %u, GLsizei bufSize = %d, GLsizei *length = 0x%016" PRIxPTR
          ", GLchar *infoLog = 0x%016" PRIxPTR ")",
          shader, bufSize, (uintptr_t)length, (uintptr_t)infoLog);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetShaderInfoLog(context, shader, bufSize, length, infoLog));
        if (isCallValid)
        {
            context->getShaderInfoLog(shader, bufSize, length, infoLog);
        }
        ANGLE_CAPTURE(GetShaderInfoLog, isCallValid, context, shader, bufSize, length, infoLog);
    }
}

void GL_APIENTRY GetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
    EVENT("(GLuint shader = %u, GLsizei bufSize = %d, GLsizei *length = 0x%016" PRIxPTR
          ", GLchar *source = 0x%016" PRIxPTR ")",
          shader, bufSize, (uintptr_t)length, (uintptr_t)source);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetShaderSource(context, shader, bufSize, length, source));
        if (isCallValid)
        {
            context->getShaderSource(shader, bufSize, length, source);
        }
        ANGLE_CAPTURE(GetShaderSource, isCallValid, context, shader, bufSize, length, source);
    }
}

void GL_APIENTRY GetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
    EVENT("(GLuint shader = %u, GLenum pname = %s, GLint *params = 0x%016" PRIxPTR ")", shader,
          GLenumToString(GLenumGroup::ShaderParameterName, pname), (uintptr_t)params);

    Context *context = GetGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetShaderiv(context, shader, pname, params));
        if (isCallValid)
        {
            context->getShaderiv(shader, pname, params);
        }
        ANGLE_CAPTURE(GetShaderiv, isCallValid, context, shader, pname, params);
    }
}

GLint GL_APIENTRY GetUniformLocation(GLuint program, const GLchar *name)
{
    EVENT("(GLuint program = %u, const GLchar *name = 0x%016" PRIxPTR ")", program,
          (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    GLint returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetUniformLocation(context, program, name));
        if (isCallValid)
        {
            returnValue = context->getUniformLocation(program, name);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::GetUniformLocation, GLint>();
        }
        ANGLE_CAPTURE(GetUniformLocation, isCallValid, context, program, name, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::GetUniformLocation, GLint>();
    }
    return returnValue;
}

void GL_APIENTRY GetUniformfv(GLuint program, GLint location, GLfloat *params)
{
    EVENT("(GLuint program = %u, GLint location = %d, GLfloat *params = 0x%016" PRIxPTR ")",
          program, location, (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetUniformfv(context, program, location, params));
        if (isCallValid)
        {
            context->getUniformfv(program, location, params);
        }
        ANGLE_CAPTURE(GetUniformfv, isCallValid, context, program, location, params);
    }
}

void GL_APIENTRY GetUniformiv(GLuint program, GLint location, GLint *params)
{
    EVENT("(GLuint program = %u, GLint location = %d, GLint *params = 0x%016" PRIxPTR ")", program,
          location, (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetUniformiv(context, program, location, params));
        if (isCallValid)
        {
            context->getUniformiv(program, location, params);
        }
        ANGLE_CAPTURE(GetUniformiv, isCallValid, context, program, location, params);
    }
}

void GL_APIENTRY GetVertexAttribPointerv(GLuint index, GLenum pname, void **pointer)
{
    EVENT("(GLuint index = %u, GLenum pname = %s, void **pointer = 0x%016" PRIxPTR ")", index,
          GLenumToString(GLenumGroup::DefaultGroup, pname), (uintptr_t)pointer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetVertexAttribPointerv(context, index, pname, pointer));
        if (isCallValid)
        {
            context->getVertexAttribPointerv(index, pname, pointer);
        }
        ANGLE_CAPTURE(GetVertexAttribPointerv, isCallValid, context, index, pname, pointer);
    }
}

void GL_APIENTRY GetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
    EVENT("(GLuint index = %u, GLenum pname = %s, GLdouble *params = 0x%016" PRIxPTR ")", index,
          GLenumToString(GLenumGroup::DefaultGroup, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetVertexAttribdv(context, index, pname, params));
        if (isCallValid)
        {
            context->getVertexAttribdv(index, pname, params);
        }
        ANGLE_CAPTURE(GetVertexAttribdv, isCallValid, context, index, pname, params);
    }
}

void GL_APIENTRY GetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
    EVENT("(GLuint index = %u, GLenum pname = %s, GLfloat *params = 0x%016" PRIxPTR ")", index,
          GLenumToString(GLenumGroup::DefaultGroup, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetVertexAttribfv(context, index, pname, params));
        if (isCallValid)
        {
            context->getVertexAttribfv(index, pname, params);
        }
        ANGLE_CAPTURE(GetVertexAttribfv, isCallValid, context, index, pname, params);
    }
}

void GL_APIENTRY GetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
    EVENT("(GLuint index = %u, GLenum pname = %s, GLint *params = 0x%016" PRIxPTR ")", index,
          GLenumToString(GLenumGroup::DefaultGroup, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetVertexAttribiv(context, index, pname, params));
        if (isCallValid)
        {
            context->getVertexAttribiv(index, pname, params);
        }
        ANGLE_CAPTURE(GetVertexAttribiv, isCallValid, context, index, pname, params);
    }
}

GLboolean GL_APIENTRY IsProgram(GLuint program)
{
    EVENT("(GLuint program = %u)", program);

    Context *context = GetValidGlobalContext();
    GLboolean returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateIsProgram(context, program));
        if (isCallValid)
        {
            returnValue = context->isProgram(program);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::IsProgram, GLboolean>();
        }
        ANGLE_CAPTURE(IsProgram, isCallValid, context, program, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::IsProgram, GLboolean>();
    }
    return returnValue;
}

GLboolean GL_APIENTRY IsShader(GLuint shader)
{
    EVENT("(GLuint shader = %u)", shader);

    Context *context = GetValidGlobalContext();
    GLboolean returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateIsShader(context, shader));
        if (isCallValid)
        {
            returnValue = context->isShader(shader);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::IsShader, GLboolean>();
        }
        ANGLE_CAPTURE(IsShader, isCallValid, context, shader, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::IsShader, GLboolean>();
    }
    return returnValue;
}

void GL_APIENTRY LinkProgram(GLuint program)
{
    EVENT("(GLuint program = %u)", program);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateLinkProgram(context, program));
        if (isCallValid)
        {
            context->linkProgram(program);
        }
        ANGLE_CAPTURE(LinkProgram, isCallValid, context, program);
    }
}

void GL_APIENTRY ShaderSource(GLuint shader,
                              GLsizei count,
                              const GLchar *const *string,
                              const GLint *length)
{
    EVENT("(GLuint shader = %u, GLsizei count = %d, const GLchar *const*string = 0x%016" PRIxPTR
          ", const GLint *length = 0x%016" PRIxPTR ")",
          shader, count, (uintptr_t)string, (uintptr_t)length);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateShaderSource(context, shader, count, string, length));
        if (isCallValid)
        {
            context->shaderSource(shader, count, string, length);
        }
        ANGLE_CAPTURE(ShaderSource, isCallValid, context, shader, count, string, length);
    }
}

void GL_APIENTRY StencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
    EVENT("(GLenum face = %s, GLenum func = %s, GLint ref = %d, GLuint mask = %u)",
          GLenumToString(GLenumGroup::StencilFaceDirection, face),
          GLenumToString(GLenumGroup::StencilFunction, func), ref, mask);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateStencilFuncSeparate(context, face, func, ref, mask));
        if (isCallValid)
        {
            context->stencilFuncSeparate(face, func, ref, mask);
        }
        ANGLE_CAPTURE(StencilFuncSeparate, isCallValid, context, face, func, ref, mask);
    }
}

void GL_APIENTRY StencilMaskSeparate(GLenum face, GLuint mask)
{
    EVENT("(GLenum face = %s, GLuint mask = %u)",
          GLenumToString(GLenumGroup::StencilFaceDirection, face), mask);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateStencilMaskSeparate(context, face, mask));
        if (isCallValid)
        {
            context->stencilMaskSeparate(face, mask);
        }
        ANGLE_CAPTURE(StencilMaskSeparate, isCallValid, context, face, mask);
    }
}

void GL_APIENTRY StencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
    EVENT("(GLenum face = %s, GLenum sfail = %s, GLenum dpfail = %s, GLenum dppass = %s)",
          GLenumToString(GLenumGroup::StencilFaceDirection, face),
          GLenumToString(GLenumGroup::StencilOp, sfail),
          GLenumToString(GLenumGroup::StencilOp, dpfail),
          GLenumToString(GLenumGroup::StencilOp, dppass));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateStencilOpSeparate(context, face, sfail, dpfail, dppass));
        if (isCallValid)
        {
            context->stencilOpSeparate(face, sfail, dpfail, dppass);
        }
        ANGLE_CAPTURE(StencilOpSeparate, isCallValid, context, face, sfail, dpfail, dppass);
    }
}

void GL_APIENTRY Uniform1f(GLint location, GLfloat v0)
{
    EVENT("(GLint location = %d, GLfloat v0 = %f)", location, v0);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateUniform1f(context, location, v0));
        if (isCallValid)
        {
            context->uniform1f(location, v0);
        }
        ANGLE_CAPTURE(Uniform1f, isCallValid, context, location, v0);
    }
}

void GL_APIENTRY Uniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform1fv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform1fv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform1fv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform1i(GLint location, GLint v0)
{
    EVENT("(GLint location = %d, GLint v0 = %d)", location, v0);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateUniform1i(context, location, v0));
        if (isCallValid)
        {
            context->uniform1i(location, v0);
        }
        ANGLE_CAPTURE(Uniform1i, isCallValid, context, location, v0);
    }
}

void GL_APIENTRY Uniform1iv(GLint location, GLsizei count, const GLint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform1iv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform1iv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform1iv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform2f(GLint location, GLfloat v0, GLfloat v1)
{
    EVENT("(GLint location = %d, GLfloat v0 = %f, GLfloat v1 = %f)", location, v0, v1);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2f(context, location, v0, v1));
        if (isCallValid)
        {
            context->uniform2f(location, v0, v1);
        }
        ANGLE_CAPTURE(Uniform2f, isCallValid, context, location, v0, v1);
    }
}

void GL_APIENTRY Uniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2fv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform2fv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform2fv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform2i(GLint location, GLint v0, GLint v1)
{
    EVENT("(GLint location = %d, GLint v0 = %d, GLint v1 = %d)", location, v0, v1);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2i(context, location, v0, v1));
        if (isCallValid)
        {
            context->uniform2i(location, v0, v1);
        }
        ANGLE_CAPTURE(Uniform2i, isCallValid, context, location, v0, v1);
    }
}

void GL_APIENTRY Uniform2iv(GLint location, GLsizei count, const GLint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2iv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform2iv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform2iv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
    EVENT("(GLint location = %d, GLfloat v0 = %f, GLfloat v1 = %f, GLfloat v2 = %f)", location, v0,
          v1, v2);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3f(context, location, v0, v1, v2));
        if (isCallValid)
        {
            context->uniform3f(location, v0, v1, v2);
        }
        ANGLE_CAPTURE(Uniform3f, isCallValid, context, location, v0, v1, v2);
    }
}

void GL_APIENTRY Uniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3fv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform3fv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform3fv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
    EVENT("(GLint location = %d, GLint v0 = %d, GLint v1 = %d, GLint v2 = %d)", location, v0, v1,
          v2);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3i(context, location, v0, v1, v2));
        if (isCallValid)
        {
            context->uniform3i(location, v0, v1, v2);
        }
        ANGLE_CAPTURE(Uniform3i, isCallValid, context, location, v0, v1, v2);
    }
}

void GL_APIENTRY Uniform3iv(GLint location, GLsizei count, const GLint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3iv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform3iv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform3iv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
    EVENT(
        "(GLint location = %d, GLfloat v0 = %f, GLfloat v1 = %f, GLfloat v2 = %f, GLfloat v3 = %f)",
        location, v0, v1, v2, v3);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4f(context, location, v0, v1, v2, v3));
        if (isCallValid)
        {
            context->uniform4f(location, v0, v1, v2, v3);
        }
        ANGLE_CAPTURE(Uniform4f, isCallValid, context, location, v0, v1, v2, v3);
    }
}

void GL_APIENTRY Uniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4fv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform4fv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform4fv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
    EVENT("(GLint location = %d, GLint v0 = %d, GLint v1 = %d, GLint v2 = %d, GLint v3 = %d)",
          location, v0, v1, v2, v3);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4i(context, location, v0, v1, v2, v3));
        if (isCallValid)
        {
            context->uniform4i(location, v0, v1, v2, v3);
        }
        ANGLE_CAPTURE(Uniform4i, isCallValid, context, location, v0, v1, v2, v3);
    }
}

void GL_APIENTRY Uniform4iv(GLint location, GLsizei count, const GLint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4iv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform4iv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform4iv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY UniformMatrix2fv(GLint location,
                                  GLsizei count,
                                  GLboolean transpose,
                                  const GLfloat *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLfloat *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix2fv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix2fv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix2fv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix3fv(GLint location,
                                  GLsizei count,
                                  GLboolean transpose,
                                  const GLfloat *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLfloat *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix3fv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix3fv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix3fv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix4fv(GLint location,
                                  GLsizei count,
                                  GLboolean transpose,
                                  const GLfloat *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLfloat *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix4fv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix4fv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix4fv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UseProgram(GLuint program)
{
    EVENT("(GLuint program = %u)", program);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateUseProgram(context, program));
        if (isCallValid)
        {
            context->useProgram(program);
        }
        ANGLE_CAPTURE(UseProgram, isCallValid, context, program);
    }
}

void GL_APIENTRY ValidateProgram(GLuint program)
{
    EVENT("(GLuint program = %u)", program);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateValidateProgram(context, program));
        if (isCallValid)
        {
            context->validateProgram(program);
        }
        ANGLE_CAPTURE(ValidateProgram, isCallValid, context, program);
    }
}

void GL_APIENTRY VertexAttrib1d(GLuint index, GLdouble x)
{
    EVENT("(GLuint index = %u, GLdouble x = %f)", index, x);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateVertexAttrib1d(context, index, x));
        if (isCallValid)
        {
            context->vertexAttrib1d(index, x);
        }
        ANGLE_CAPTURE(VertexAttrib1d, isCallValid, context, index, x);
    }
}

void GL_APIENTRY VertexAttrib1dv(GLuint index, const GLdouble *v)
{
    EVENT("(GLuint index = %u, const GLdouble *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib1dv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib1dv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib1dv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib1f(GLuint index, GLfloat x)
{
    EVENT("(GLuint index = %u, GLfloat x = %f)", index, x);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateVertexAttrib1f(context, index, x));
        if (isCallValid)
        {
            context->vertexAttrib1f(index, x);
        }
        ANGLE_CAPTURE(VertexAttrib1f, isCallValid, context, index, x);
    }
}

void GL_APIENTRY VertexAttrib1fv(GLuint index, const GLfloat *v)
{
    EVENT("(GLuint index = %u, const GLfloat *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib1fv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib1fv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib1fv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib1s(GLuint index, GLshort x)
{
    EVENT("(GLuint index = %u, GLshort x = %d)", index, x);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateVertexAttrib1s(context, index, x));
        if (isCallValid)
        {
            context->vertexAttrib1s(index, x);
        }
        ANGLE_CAPTURE(VertexAttrib1s, isCallValid, context, index, x);
    }
}

void GL_APIENTRY VertexAttrib1sv(GLuint index, const GLshort *v)
{
    EVENT("(GLuint index = %u, const GLshort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib1sv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib1sv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib1sv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
    EVENT("(GLuint index = %u, GLdouble x = %f, GLdouble y = %f)", index, x, y);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib2d(context, index, x, y));
        if (isCallValid)
        {
            context->vertexAttrib2d(index, x, y);
        }
        ANGLE_CAPTURE(VertexAttrib2d, isCallValid, context, index, x, y);
    }
}

void GL_APIENTRY VertexAttrib2dv(GLuint index, const GLdouble *v)
{
    EVENT("(GLuint index = %u, const GLdouble *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib2dv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib2dv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib2dv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
    EVENT("(GLuint index = %u, GLfloat x = %f, GLfloat y = %f)", index, x, y);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib2f(context, index, x, y));
        if (isCallValid)
        {
            context->vertexAttrib2f(index, x, y);
        }
        ANGLE_CAPTURE(VertexAttrib2f, isCallValid, context, index, x, y);
    }
}

void GL_APIENTRY VertexAttrib2fv(GLuint index, const GLfloat *v)
{
    EVENT("(GLuint index = %u, const GLfloat *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib2fv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib2fv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib2fv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
    EVENT("(GLuint index = %u, GLshort x = %d, GLshort y = %d)", index, x, y);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib2s(context, index, x, y));
        if (isCallValid)
        {
            context->vertexAttrib2s(index, x, y);
        }
        ANGLE_CAPTURE(VertexAttrib2s, isCallValid, context, index, x, y);
    }
}

void GL_APIENTRY VertexAttrib2sv(GLuint index, const GLshort *v)
{
    EVENT("(GLuint index = %u, const GLshort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib2sv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib2sv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib2sv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    EVENT("(GLuint index = %u, GLdouble x = %f, GLdouble y = %f, GLdouble z = %f)", index, x, y, z);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib3d(context, index, x, y, z));
        if (isCallValid)
        {
            context->vertexAttrib3d(index, x, y, z);
        }
        ANGLE_CAPTURE(VertexAttrib3d, isCallValid, context, index, x, y, z);
    }
}

void GL_APIENTRY VertexAttrib3dv(GLuint index, const GLdouble *v)
{
    EVENT("(GLuint index = %u, const GLdouble *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib3dv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib3dv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib3dv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    EVENT("(GLuint index = %u, GLfloat x = %f, GLfloat y = %f, GLfloat z = %f)", index, x, y, z);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib3f(context, index, x, y, z));
        if (isCallValid)
        {
            context->vertexAttrib3f(index, x, y, z);
        }
        ANGLE_CAPTURE(VertexAttrib3f, isCallValid, context, index, x, y, z);
    }
}

void GL_APIENTRY VertexAttrib3fv(GLuint index, const GLfloat *v)
{
    EVENT("(GLuint index = %u, const GLfloat *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib3fv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib3fv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib3fv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
    EVENT("(GLuint index = %u, GLshort x = %d, GLshort y = %d, GLshort z = %d)", index, x, y, z);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib3s(context, index, x, y, z));
        if (isCallValid)
        {
            context->vertexAttrib3s(index, x, y, z);
        }
        ANGLE_CAPTURE(VertexAttrib3s, isCallValid, context, index, x, y, z);
    }
}

void GL_APIENTRY VertexAttrib3sv(GLuint index, const GLshort *v)
{
    EVENT("(GLuint index = %u, const GLshort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib3sv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib3sv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib3sv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
    EVENT("(GLuint index = %u, const GLbyte *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4Nbv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4Nbv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4Nbv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4Niv(GLuint index, const GLint *v)
{
    EVENT("(GLuint index = %u, const GLint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4Niv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4Niv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4Niv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4Nsv(GLuint index, const GLshort *v)
{
    EVENT("(GLuint index = %u, const GLshort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4Nsv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4Nsv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4Nsv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
    EVENT("(GLuint index = %u, GLubyte x = %d, GLubyte y = %d, GLubyte z = %d, GLubyte w = %d)",
          index, x, y, z, w);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4Nub(context, index, x, y, z, w));
        if (isCallValid)
        {
            context->vertexAttrib4Nub(index, x, y, z, w);
        }
        ANGLE_CAPTURE(VertexAttrib4Nub, isCallValid, context, index, x, y, z, w);
    }
}

void GL_APIENTRY VertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
    EVENT("(GLuint index = %u, const GLubyte *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4Nubv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4Nubv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4Nubv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
    EVENT("(GLuint index = %u, const GLuint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4Nuiv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4Nuiv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4Nuiv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4Nusv(GLuint index, const GLushort *v)
{
    EVENT("(GLuint index = %u, const GLushort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4Nusv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4Nusv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4Nusv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4bv(GLuint index, const GLbyte *v)
{
    EVENT("(GLuint index = %u, const GLbyte *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4bv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4bv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4bv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    EVENT("(GLuint index = %u, GLdouble x = %f, GLdouble y = %f, GLdouble z = %f, GLdouble w = %f)",
          index, x, y, z, w);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4d(context, index, x, y, z, w));
        if (isCallValid)
        {
            context->vertexAttrib4d(index, x, y, z, w);
        }
        ANGLE_CAPTURE(VertexAttrib4d, isCallValid, context, index, x, y, z, w);
    }
}

void GL_APIENTRY VertexAttrib4dv(GLuint index, const GLdouble *v)
{
    EVENT("(GLuint index = %u, const GLdouble *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4dv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4dv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4dv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    EVENT("(GLuint index = %u, GLfloat x = %f, GLfloat y = %f, GLfloat z = %f, GLfloat w = %f)",
          index, x, y, z, w);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4f(context, index, x, y, z, w));
        if (isCallValid)
        {
            context->vertexAttrib4f(index, x, y, z, w);
        }
        ANGLE_CAPTURE(VertexAttrib4f, isCallValid, context, index, x, y, z, w);
    }
}

void GL_APIENTRY VertexAttrib4fv(GLuint index, const GLfloat *v)
{
    EVENT("(GLuint index = %u, const GLfloat *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4fv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4fv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4fv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4iv(GLuint index, const GLint *v)
{
    EVENT("(GLuint index = %u, const GLint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4iv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4iv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4iv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
    EVENT("(GLuint index = %u, GLshort x = %d, GLshort y = %d, GLshort z = %d, GLshort w = %d)",
          index, x, y, z, w);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4s(context, index, x, y, z, w));
        if (isCallValid)
        {
            context->vertexAttrib4s(index, x, y, z, w);
        }
        ANGLE_CAPTURE(VertexAttrib4s, isCallValid, context, index, x, y, z, w);
    }
}

void GL_APIENTRY VertexAttrib4sv(GLuint index, const GLshort *v)
{
    EVENT("(GLuint index = %u, const GLshort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4sv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4sv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4sv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4ubv(GLuint index, const GLubyte *v)
{
    EVENT("(GLuint index = %u, const GLubyte *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4ubv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4ubv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4ubv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4uiv(GLuint index, const GLuint *v)
{
    EVENT("(GLuint index = %u, const GLuint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4uiv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4uiv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4uiv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttrib4usv(GLuint index, const GLushort *v)
{
    EVENT("(GLuint index = %u, const GLushort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttrib4usv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttrib4usv(index, v);
        }
        ANGLE_CAPTURE(VertexAttrib4usv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribPointer(GLuint index,
                                     GLint size,
                                     GLenum type,
                                     GLboolean normalized,
                                     GLsizei stride,
                                     const void *pointer)
{
    EVENT(
        "(GLuint index = %u, GLint size = %d, GLenum type = %s, GLboolean normalized = %s, GLsizei "
        "stride = %d, const void *pointer = 0x%016" PRIxPTR ")",
        index, size, GLenumToString(GLenumGroup::VertexAttribPointerType, type),
        GLbooleanToString(normalized), stride, (uintptr_t)pointer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        VertexAttribType typePacked                   = FromGL<VertexAttribType>(type);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateVertexAttribPointer(context, index, size, typePacked,
                                                        normalized, stride, pointer));
        if (isCallValid)
        {
            context->vertexAttribPointer(index, size, typePacked, normalized, stride, pointer);
        }
        ANGLE_CAPTURE(VertexAttribPointer, isCallValid, context, index, size, typePacked,
                      normalized, stride, pointer);
    }
}
}  // namespace gl
