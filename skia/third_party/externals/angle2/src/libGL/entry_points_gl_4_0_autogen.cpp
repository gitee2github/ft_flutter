// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// entry_points_gl_4_0_autogen.cpp:
//   Defines the GL 4.0 entry points.

#include "libGL/entry_points_gl_4_0_autogen.h"

#include "libANGLE/Context.h"
#include "libANGLE/Context.inl.h"
#include "libANGLE/entry_points_utils.h"
#include "libANGLE/gl_enum_utils_autogen.h"
#include "libANGLE/validationEGL.h"
#include "libANGLE/validationES.h"
#include "libANGLE/validationES1.h"
#include "libANGLE/validationES2.h"
#include "libANGLE/validationES3.h"
#include "libANGLE/validationES31.h"
#include "libANGLE/validationESEXT.h"
#include "libANGLE/validationGL4_autogen.h"
#include "libGLESv2/global_state.h"

namespace gl
{
void GL_APIENTRY BeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
    EVENT("(GLenum target = %s, GLuint index = %u, GLuint id = %u)",
          GLenumToString(GLenumGroup::QueryTarget, target), index, id);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateBeginQueryIndexed(context, target, index, id));
        if (isCallValid)
        {
            context->beginQueryIndexed(target, index, id);
        }
        ANGLE_CAPTURE(BeginQueryIndexed, isCallValid, context, target, index, id);
    }
}

void GL_APIENTRY BindTransformFeedback(GLenum target, GLuint id)
{
    EVENT("(GLenum target = %s, GLuint id = %u)",
          GLenumToString(GLenumGroup::BindTransformFeedbackTarget, target), id);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateBindTransformFeedback(context, target, id));
        if (isCallValid)
        {
            context->bindTransformFeedback(target, id);
        }
        ANGLE_CAPTURE(BindTransformFeedback, isCallValid, context, target, id);
    }
}

void GL_APIENTRY BlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
    EVENT("(GLuint buf = %u, GLenum modeRGB = %s, GLenum modeAlpha = %s)", buf,
          GLenumToString(GLenumGroup::BlendEquationModeEXT, modeRGB),
          GLenumToString(GLenumGroup::BlendEquationModeEXT, modeAlpha));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBlendEquationSeparatei(context, buf, modeRGB, modeAlpha));
        if (isCallValid)
        {
            context->blendEquationSeparatei(buf, modeRGB, modeAlpha);
        }
        ANGLE_CAPTURE(BlendEquationSeparatei, isCallValid, context, buf, modeRGB, modeAlpha);
    }
}

void GL_APIENTRY BlendEquationi(GLuint buf, GLenum mode)
{
    EVENT("(GLuint buf = %u, GLenum mode = %s)", buf,
          GLenumToString(GLenumGroup::BlendEquationModeEXT, mode));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateBlendEquationi(context, buf, mode));
        if (isCallValid)
        {
            context->blendEquationi(buf, mode);
        }
        ANGLE_CAPTURE(BlendEquationi, isCallValid, context, buf, mode);
    }
}

void GL_APIENTRY
BlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
    EVENT(
        "(GLuint buf = %u, GLenum srcRGB = %s, GLenum dstRGB = %s, GLenum srcAlpha = %s, GLenum "
        "dstAlpha = %s)",
        buf, GLenumToString(GLenumGroup::BlendingFactor, srcRGB),
        GLenumToString(GLenumGroup::BlendingFactor, dstRGB),
        GLenumToString(GLenumGroup::BlendingFactor, srcAlpha),
        GLenumToString(GLenumGroup::BlendingFactor, dstAlpha));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateBlendFuncSeparatei(context, buf, srcRGB, dstRGB, srcAlpha, dstAlpha));
        if (isCallValid)
        {
            context->blendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        ANGLE_CAPTURE(BlendFuncSeparatei, isCallValid, context, buf, srcRGB, dstRGB, srcAlpha,
                      dstAlpha);
    }
}

void GL_APIENTRY BlendFunci(GLuint buf, GLenum src, GLenum dst)
{
    EVENT("(GLuint buf = %u, GLenum src = %s, GLenum dst = %s)", buf,
          GLenumToString(GLenumGroup::BlendingFactor, src),
          GLenumToString(GLenumGroup::BlendingFactor, dst));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateBlendFunci(context, buf, src, dst));
        if (isCallValid)
        {
            context->blendFunci(buf, src, dst);
        }
        ANGLE_CAPTURE(BlendFunci, isCallValid, context, buf, src, dst);
    }
}

void GL_APIENTRY DeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
    EVENT("(GLsizei n = %d, const GLuint *ids = 0x%016" PRIxPTR ")", n, (uintptr_t)ids);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateDeleteTransformFeedbacks(context, n, ids));
        if (isCallValid)
        {
            context->deleteTransformFeedbacks(n, ids);
        }
        ANGLE_CAPTURE(DeleteTransformFeedbacks, isCallValid, context, n, ids);
    }
}

void GL_APIENTRY DrawArraysIndirect(GLenum mode, const void *indirect)
{
    EVENT("(GLenum mode = %s, const void *indirect = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::PrimitiveType, mode), (uintptr_t)indirect);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        PrimitiveMode modePacked                      = FromGL<PrimitiveMode>(mode);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateDrawArraysIndirect(context, modePacked, indirect));
        if (isCallValid)
        {
            context->drawArraysIndirect(modePacked, indirect);
        }
        ANGLE_CAPTURE(DrawArraysIndirect, isCallValid, context, modePacked, indirect);
    }
}

void GL_APIENTRY DrawElementsIndirect(GLenum mode, GLenum type, const void *indirect)
{
    EVENT("(GLenum mode = %s, GLenum type = %s, const void *indirect = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::PrimitiveType, mode),
          GLenumToString(GLenumGroup::DrawElementsType, type), (uintptr_t)indirect);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        PrimitiveMode modePacked                      = FromGL<PrimitiveMode>(mode);
        DrawElementsType typePacked                   = FromGL<DrawElementsType>(type);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateDrawElementsIndirect(context, modePacked, typePacked, indirect));
        if (isCallValid)
        {
            context->drawElementsIndirect(modePacked, typePacked, indirect);
        }
        ANGLE_CAPTURE(DrawElementsIndirect, isCallValid, context, modePacked, typePacked, indirect);
    }
}

void GL_APIENTRY DrawTransformFeedback(GLenum mode, GLuint id)
{
    EVENT("(GLenum mode = %s, GLuint id = %u)", GLenumToString(GLenumGroup::PrimitiveType, mode),
          id);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateDrawTransformFeedback(context, mode, id));
        if (isCallValid)
        {
            context->drawTransformFeedback(mode, id);
        }
        ANGLE_CAPTURE(DrawTransformFeedback, isCallValid, context, mode, id);
    }
}

void GL_APIENTRY DrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
    EVENT("(GLenum mode = %s, GLuint id = %u, GLuint stream = %u)",
          GLenumToString(GLenumGroup::PrimitiveType, mode), id, stream);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateDrawTransformFeedbackStream(context, mode, id, stream));
        if (isCallValid)
        {
            context->drawTransformFeedbackStream(mode, id, stream);
        }
        ANGLE_CAPTURE(DrawTransformFeedbackStream, isCallValid, context, mode, id, stream);
    }
}

void GL_APIENTRY EndQueryIndexed(GLenum target, GLuint index)
{
    EVENT("(GLenum target = %s, GLuint index = %u)",
          GLenumToString(GLenumGroup::QueryTarget, target), index);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateEndQueryIndexed(context, target, index));
        if (isCallValid)
        {
            context->endQueryIndexed(target, index);
        }
        ANGLE_CAPTURE(EndQueryIndexed, isCallValid, context, target, index);
    }
}

void GL_APIENTRY GenTransformFeedbacks(GLsizei n, GLuint *ids)
{
    EVENT("(GLsizei n = %d, GLuint *ids = 0x%016" PRIxPTR ")", n, (uintptr_t)ids);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGenTransformFeedbacks(context, n, ids));
        if (isCallValid)
        {
            context->genTransformFeedbacks(n, ids);
        }
        ANGLE_CAPTURE(GenTransformFeedbacks, isCallValid, context, n, ids);
    }
}

void GL_APIENTRY GetActiveSubroutineName(GLuint program,
                                         GLenum shadertype,
                                         GLuint index,
                                         GLsizei bufsize,
                                         GLsizei *length,
                                         GLchar *name)
{
    EVENT(
        "(GLuint program = %u, GLenum shadertype = %s, GLuint index = %u, GLsizei bufsize = %d, "
        "GLsizei *length = 0x%016" PRIxPTR ", GLchar *name = 0x%016" PRIxPTR ")",
        program, GLenumToString(GLenumGroup::ShaderType, shadertype), index, bufsize,
        (uintptr_t)length, (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetActiveSubroutineName(context, program, shadertype, index,
                                                            bufsize, length, name));
        if (isCallValid)
        {
            context->getActiveSubroutineName(program, shadertype, index, bufsize, length, name);
        }
        ANGLE_CAPTURE(GetActiveSubroutineName, isCallValid, context, program, shadertype, index,
                      bufsize, length, name);
    }
}

void GL_APIENTRY GetActiveSubroutineUniformName(GLuint program,
                                                GLenum shadertype,
                                                GLuint index,
                                                GLsizei bufsize,
                                                GLsizei *length,
                                                GLchar *name)
{
    EVENT(
        "(GLuint program = %u, GLenum shadertype = %s, GLuint index = %u, GLsizei bufsize = %d, "
        "GLsizei *length = 0x%016" PRIxPTR ", GLchar *name = 0x%016" PRIxPTR ")",
        program, GLenumToString(GLenumGroup::ShaderType, shadertype), index, bufsize,
        (uintptr_t)length, (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetActiveSubroutineUniformName(context, program, shadertype,
                                                                   index, bufsize, length, name));
        if (isCallValid)
        {
            context->getActiveSubroutineUniformName(program, shadertype, index, bufsize, length,
                                                    name);
        }
        ANGLE_CAPTURE(GetActiveSubroutineUniformName, isCallValid, context, program, shadertype,
                      index, bufsize, length, name);
    }
}

void GL_APIENTRY GetActiveSubroutineUniformiv(GLuint program,
                                              GLenum shadertype,
                                              GLuint index,
                                              GLenum pname,
                                              GLint *values)
{
    EVENT(
        "(GLuint program = %u, GLenum shadertype = %s, GLuint index = %u, GLenum pname = %s, GLint "
        "*values = 0x%016" PRIxPTR ")",
        program, GLenumToString(GLenumGroup::ShaderType, shadertype), index,
        GLenumToString(GLenumGroup::SubroutineParameterName, pname), (uintptr_t)values);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetActiveSubroutineUniformiv(
                                              context, program, shadertype, index, pname, values));
        if (isCallValid)
        {
            context->getActiveSubroutineUniformiv(program, shadertype, index, pname, values);
        }
        ANGLE_CAPTURE(GetActiveSubroutineUniformiv, isCallValid, context, program, shadertype,
                      index, pname, values);
    }
}

void GL_APIENTRY GetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values)
{
    EVENT(
        "(GLuint program = %u, GLenum shadertype = %s, GLenum pname = %s, GLint *values = "
        "0x%016" PRIxPTR ")",
        program, GLenumToString(GLenumGroup::ShaderType, shadertype),
        GLenumToString(GLenumGroup::ProgramStagePName, pname), (uintptr_t)values);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetProgramStageiv(context, program, shadertype, pname, values));
        if (isCallValid)
        {
            context->getProgramStageiv(program, shadertype, pname, values);
        }
        ANGLE_CAPTURE(GetProgramStageiv, isCallValid, context, program, shadertype, pname, values);
    }
}

void GL_APIENTRY GetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
    EVENT(
        "(GLenum target = %s, GLuint index = %u, GLenum pname = %s, GLint *params = 0x%016" PRIxPTR
        ")",
        GLenumToString(GLenumGroup::DefaultGroup, target), index,
        GLenumToString(GLenumGroup::QueryParameterName, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetQueryIndexediv(context, target, index, pname, params));
        if (isCallValid)
        {
            context->getQueryIndexediv(target, index, pname, params);
        }
        ANGLE_CAPTURE(GetQueryIndexediv, isCallValid, context, target, index, pname, params);
    }
}

GLuint GL_APIENTRY GetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name)
{
    EVENT("(GLuint program = %u, GLenum shadertype = %s, const GLchar *name = 0x%016" PRIxPTR ")",
          program, GLenumToString(GLenumGroup::ShaderType, shadertype), (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    GLuint returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetSubroutineIndex(context, program, shadertype, name));
        if (isCallValid)
        {
            returnValue = context->getSubroutineIndex(program, shadertype, name);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::GetSubroutineIndex, GLuint>();
        }
        ANGLE_CAPTURE(GetSubroutineIndex, isCallValid, context, program, shadertype, name,
                      returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::GetSubroutineIndex, GLuint>();
    }
    return returnValue;
}

GLint GL_APIENTRY GetSubroutineUniformLocation(GLuint program,
                                               GLenum shadertype,
                                               const GLchar *name)
{
    EVENT("(GLuint program = %u, GLenum shadertype = %s, const GLchar *name = 0x%016" PRIxPTR ")",
          program, GLenumToString(GLenumGroup::ShaderType, shadertype), (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    GLint returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateGetSubroutineUniformLocation(
                                                             context, program, shadertype, name));
        if (isCallValid)
        {
            returnValue = context->getSubroutineUniformLocation(program, shadertype, name);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::GetSubroutineUniformLocation, GLint>();
        }
        ANGLE_CAPTURE(GetSubroutineUniformLocation, isCallValid, context, program, shadertype, name,
                      returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::GetSubroutineUniformLocation, GLint>();
    }
    return returnValue;
}

void GL_APIENTRY GetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *params)
{
    EVENT("(GLenum shadertype = %s, GLint location = %d, GLuint *params = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::ShaderType, shadertype), location, (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetUniformSubroutineuiv(context, shadertype, location, params));
        if (isCallValid)
        {
            context->getUniformSubroutineuiv(shadertype, location, params);
        }
        ANGLE_CAPTURE(GetUniformSubroutineuiv, isCallValid, context, shadertype, location, params);
    }
}

void GL_APIENTRY GetUniformdv(GLuint program, GLint location, GLdouble *params)
{
    EVENT("(GLuint program = %u, GLint location = %d, GLdouble *params = 0x%016" PRIxPTR ")",
          program, location, (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetUniformdv(context, program, location, params));
        if (isCallValid)
        {
            context->getUniformdv(program, location, params);
        }
        ANGLE_CAPTURE(GetUniformdv, isCallValid, context, program, location, params);
    }
}

GLboolean GL_APIENTRY IsTransformFeedback(GLuint id)
{
    EVENT("(GLuint id = %u)", id);

    Context *context = GetValidGlobalContext();
    GLboolean returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateIsTransformFeedback(context, id));
        if (isCallValid)
        {
            returnValue = context->isTransformFeedback(id);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::IsTransformFeedback, GLboolean>();
        }
        ANGLE_CAPTURE(IsTransformFeedback, isCallValid, context, id, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::IsTransformFeedback, GLboolean>();
    }
    return returnValue;
}

void GL_APIENTRY MinSampleShading(GLfloat value)
{
    EVENT("(GLfloat value = %f)", value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateMinSampleShading(context, value));
        if (isCallValid)
        {
            context->minSampleShading(value);
        }
        ANGLE_CAPTURE(MinSampleShading, isCallValid, context, value);
    }
}

void GL_APIENTRY PatchParameterfv(GLenum pname, const GLfloat *values)
{
    EVENT("(GLenum pname = %s, const GLfloat *values = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::PatchParameterName, pname), (uintptr_t)values);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidatePatchParameterfv(context, pname, values));
        if (isCallValid)
        {
            context->patchParameterfv(pname, values);
        }
        ANGLE_CAPTURE(PatchParameterfv, isCallValid, context, pname, values);
    }
}

void GL_APIENTRY PatchParameteri(GLenum pname, GLint value)
{
    EVENT("(GLenum pname = %s, GLint value = %d)",
          GLenumToString(GLenumGroup::PatchParameterName, pname), value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidatePatchParameteri(context, pname, value));
        if (isCallValid)
        {
            context->patchParameteri(pname, value);
        }
        ANGLE_CAPTURE(PatchParameteri, isCallValid, context, pname, value);
    }
}

void GL_APIENTRY PauseTransformFeedback()
{
    EVENT("()");

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidatePauseTransformFeedback(context));
        if (isCallValid)
        {
            context->pauseTransformFeedback();
        }
        ANGLE_CAPTURE(PauseTransformFeedback, isCallValid, context);
    }
}

void GL_APIENTRY ResumeTransformFeedback()
{
    EVENT("()");

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateResumeTransformFeedback(context));
        if (isCallValid)
        {
            context->resumeTransformFeedback();
        }
        ANGLE_CAPTURE(ResumeTransformFeedback, isCallValid, context);
    }
}

void GL_APIENTRY Uniform1d(GLint location, GLdouble x)
{
    EVENT("(GLint location = %d, GLdouble x = %f)", location, x);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateUniform1d(context, location, x));
        if (isCallValid)
        {
            context->uniform1d(location, x);
        }
        ANGLE_CAPTURE(Uniform1d, isCallValid, context, location, x);
    }
}

void GL_APIENTRY Uniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLdouble *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform1dv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform1dv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform1dv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform2d(GLint location, GLdouble x, GLdouble y)
{
    EVENT("(GLint location = %d, GLdouble x = %f, GLdouble y = %f)", location, x, y);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2d(context, location, x, y));
        if (isCallValid)
        {
            context->uniform2d(location, x, y);
        }
        ANGLE_CAPTURE(Uniform2d, isCallValid, context, location, x, y);
    }
}

void GL_APIENTRY Uniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLdouble *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2dv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform2dv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform2dv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
    EVENT("(GLint location = %d, GLdouble x = %f, GLdouble y = %f, GLdouble z = %f)", location, x,
          y, z);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3d(context, location, x, y, z));
        if (isCallValid)
        {
            context->uniform3d(location, x, y, z);
        }
        ANGLE_CAPTURE(Uniform3d, isCallValid, context, location, x, y, z);
    }
}

void GL_APIENTRY Uniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLdouble *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3dv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform3dv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform3dv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    EVENT(
        "(GLint location = %d, GLdouble x = %f, GLdouble y = %f, GLdouble z = %f, GLdouble w = %f)",
        location, x, y, z, w);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4d(context, location, x, y, z, w));
        if (isCallValid)
        {
            context->uniform4d(location, x, y, z, w);
        }
        ANGLE_CAPTURE(Uniform4d, isCallValid, context, location, x, y, z, w);
    }
}

void GL_APIENTRY Uniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLdouble *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4dv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform4dv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform4dv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY UniformMatrix2dv(GLint location,
                                  GLsizei count,
                                  GLboolean transpose,
                                  const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix2dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix2dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix2dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix2x3dv(GLint location,
                                    GLsizei count,
                                    GLboolean transpose,
                                    const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix2x3dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix2x3dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix2x3dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix2x4dv(GLint location,
                                    GLsizei count,
                                    GLboolean transpose,
                                    const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix2x4dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix2x4dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix2x4dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix3dv(GLint location,
                                  GLsizei count,
                                  GLboolean transpose,
                                  const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix3dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix3dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix3dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix3x2dv(GLint location,
                                    GLsizei count,
                                    GLboolean transpose,
                                    const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix3x2dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix3x2dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix3x2dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix3x4dv(GLint location,
                                    GLsizei count,
                                    GLboolean transpose,
                                    const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix3x4dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix3x4dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix3x4dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix4dv(GLint location,
                                  GLsizei count,
                                  GLboolean transpose,
                                  const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix4dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix4dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix4dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix4x2dv(GLint location,
                                    GLsizei count,
                                    GLboolean transpose,
                                    const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix4x2dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix4x2dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix4x2dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformMatrix4x3dv(GLint location,
                                    GLsizei count,
                                    GLboolean transpose,
                                    const GLdouble *value)
{
    EVENT(
        "(GLint location = %d, GLsizei count = %d, GLboolean transpose = %s, const GLdouble *value "
        "= 0x%016" PRIxPTR ")",
        location, count, GLbooleanToString(transpose), (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformMatrix4x3dv(context, location, count, transpose, value));
        if (isCallValid)
        {
            context->uniformMatrix4x3dv(location, count, transpose, value);
        }
        ANGLE_CAPTURE(UniformMatrix4x3dv, isCallValid, context, location, count, transpose, value);
    }
}

void GL_APIENTRY UniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint *indices)
{
    EVENT("(GLenum shadertype = %s, GLsizei count = %d, const GLuint *indices = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::ShaderType, shadertype), count, (uintptr_t)indices);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateUniformSubroutinesuiv(context, shadertype, count, indices));
        if (isCallValid)
        {
            context->uniformSubroutinesuiv(shadertype, count, indices);
        }
        ANGLE_CAPTURE(UniformSubroutinesuiv, isCallValid, context, shadertype, count, indices);
    }
}
}  // namespace gl
