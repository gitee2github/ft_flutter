// GENERATED FILE - DO NOT EDIT.
// Generated by generate_entry_points.py using data from gl.xml.
//
// Copyright 2019 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// entry_points_gl_3_0_autogen.cpp:
//   Defines the GL 3.0 entry points.

#include "libGL/entry_points_gl_3_0_autogen.h"

#include "libANGLE/Context.h"
#include "libANGLE/Context.inl.h"
#include "libANGLE/entry_points_utils.h"
#include "libANGLE/gl_enum_utils_autogen.h"
#include "libANGLE/validationEGL.h"
#include "libANGLE/validationES.h"
#include "libANGLE/validationES1.h"
#include "libANGLE/validationES2.h"
#include "libANGLE/validationES3.h"
#include "libANGLE/validationES31.h"
#include "libANGLE/validationESEXT.h"
#include "libANGLE/validationGL3_autogen.h"
#include "libGLESv2/global_state.h"

namespace gl
{
void GL_APIENTRY BeginConditionalRender(GLuint id, GLenum mode)
{
    EVENT("(GLuint id = %u, GLenum mode = %s)", id, GLenumToString(GLenumGroup::TypeEnum, mode));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateBeginConditionalRender(context, id, mode));
        if (isCallValid)
        {
            context->beginConditionalRender(id, mode);
        }
        ANGLE_CAPTURE(BeginConditionalRender, isCallValid, context, id, mode);
    }
}

void GL_APIENTRY BeginTransformFeedback(GLenum primitiveMode)
{
    EVENT("(GLenum primitiveMode = %s)", GLenumToString(GLenumGroup::PrimitiveType, primitiveMode));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        PrimitiveMode primitiveModePacked             = FromGL<PrimitiveMode>(primitiveMode);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBeginTransformFeedback(context, primitiveModePacked));
        if (isCallValid)
        {
            context->beginTransformFeedback(primitiveModePacked);
        }
        ANGLE_CAPTURE(BeginTransformFeedback, isCallValid, context, primitiveModePacked);
    }
}

void GL_APIENTRY BindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
    EVENT("(GLenum target = %s, GLuint index = %u, GLuint buffer = %u)",
          GLenumToString(GLenumGroup::BufferTargetARB, target), index, buffer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        BufferBinding targetPacked                    = FromGL<BufferBinding>(target);
        BufferID bufferPacked                         = FromGL<BufferID>(buffer);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBindBufferBase(context, targetPacked, index, bufferPacked));
        if (isCallValid)
        {
            context->bindBufferBase(targetPacked, index, bufferPacked);
        }
        ANGLE_CAPTURE(BindBufferBase, isCallValid, context, targetPacked, index, bufferPacked);
    }
}

void GL_APIENTRY
BindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    EVENT(
        "(GLenum target = %s, GLuint index = %u, GLuint buffer = %u, GLintptr offset = %llu, "
        "GLsizeiptr size = %llu)",
        GLenumToString(GLenumGroup::BufferTargetARB, target), index, buffer,
        static_cast<unsigned long long>(offset), static_cast<unsigned long long>(size));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        BufferBinding targetPacked                    = FromGL<BufferBinding>(target);
        BufferID bufferPacked                         = FromGL<BufferID>(buffer);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateBindBufferRange(context, targetPacked, index, bufferPacked, offset, size));
        if (isCallValid)
        {
            context->bindBufferRange(targetPacked, index, bufferPacked, offset, size);
        }
        ANGLE_CAPTURE(BindBufferRange, isCallValid, context, targetPacked, index, bufferPacked,
                      offset, size);
    }
}

void GL_APIENTRY BindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
    EVENT("(GLuint program = %u, GLuint color = %u, const GLchar *name = 0x%016" PRIxPTR ")",
          program, color, (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBindFragDataLocation(context, program, color, name));
        if (isCallValid)
        {
            context->bindFragDataLocation(program, color, name);
        }
        ANGLE_CAPTURE(BindFragDataLocation, isCallValid, context, program, color, name);
    }
}

void GL_APIENTRY BindFramebuffer(GLenum target, GLuint framebuffer)
{
    EVENT("(GLenum target = %s, GLuint framebuffer = %u)",
          GLenumToString(GLenumGroup::FramebufferTarget, target), framebuffer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateBindFramebuffer(context, target, framebuffer));
        if (isCallValid)
        {
            context->bindFramebuffer(target, framebuffer);
        }
        ANGLE_CAPTURE(BindFramebuffer, isCallValid, context, target, framebuffer);
    }
}

void GL_APIENTRY BindRenderbuffer(GLenum target, GLuint renderbuffer)
{
    EVENT("(GLenum target = %s, GLuint renderbuffer = %u)",
          GLenumToString(GLenumGroup::RenderbufferTarget, target), renderbuffer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        RenderbufferID renderbufferPacked             = FromGL<RenderbufferID>(renderbuffer);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBindRenderbuffer(context, target, renderbufferPacked));
        if (isCallValid)
        {
            context->bindRenderbuffer(target, renderbufferPacked);
        }
        ANGLE_CAPTURE(BindRenderbuffer, isCallValid, context, target, renderbufferPacked);
    }
}

void GL_APIENTRY BindVertexArray(GLuint array)
{
    EVENT("(GLuint array = %u)", array);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateBindVertexArray(context, array));
        if (isCallValid)
        {
            context->bindVertexArray(array);
        }
        ANGLE_CAPTURE(BindVertexArray, isCallValid, context, array);
    }
}

void GL_APIENTRY BlitFramebuffer(GLint srcX0,
                                 GLint srcY0,
                                 GLint srcX1,
                                 GLint srcY1,
                                 GLint dstX0,
                                 GLint dstY0,
                                 GLint dstX1,
                                 GLint dstY1,
                                 GLbitfield mask,
                                 GLenum filter)
{
    EVENT(
        "(GLint srcX0 = %d, GLint srcY0 = %d, GLint srcX1 = %d, GLint srcY1 = %d, GLint dstX0 = "
        "%d, GLint dstY0 = %d, GLint dstX1 = %d, GLint dstY1 = %d, GLbitfield mask = %s, GLenum "
        "filter = %s)",
        srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1,
        GLbitfieldToString(GLenumGroup::ClearBufferMask, mask).c_str(),
        GLenumToString(GLenumGroup::BlitFramebufferFilter, filter));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateBlitFramebuffer(context, srcX0, srcY0, srcX1, srcY1, dstX0,
                                                    dstY0, dstX1, dstY1, mask, filter));
        if (isCallValid)
        {
            context->blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask,
                                     filter);
        }
        ANGLE_CAPTURE(BlitFramebuffer, isCallValid, context, srcX0, srcY0, srcX1, srcY1, dstX0,
                      dstY0, dstX1, dstY1, mask, filter);
    }
}

GLenum GL_APIENTRY CheckFramebufferStatus(GLenum target)
{
    EVENT("(GLenum target = %s)", GLenumToString(GLenumGroup::FramebufferTarget, target));

    Context *context = GetValidGlobalContext();
    GLenum returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateCheckFramebufferStatus(context, target));
        if (isCallValid)
        {
            returnValue = context->checkFramebufferStatus(target);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::CheckFramebufferStatus, GLenum>();
        }
        ANGLE_CAPTURE(CheckFramebufferStatus, isCallValid, context, target, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::CheckFramebufferStatus, GLenum>();
    }
    return returnValue;
}

void GL_APIENTRY ClampColor(GLenum target, GLenum clamp)
{
    EVENT("(GLenum target = %s, GLenum clamp = %s)",
          GLenumToString(GLenumGroup::DefaultGroup, target),
          GLenumToString(GLenumGroup::DefaultGroup, clamp));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateClampColor(context, target, clamp));
        if (isCallValid)
        {
            context->clampColor(target, clamp);
        }
        ANGLE_CAPTURE(ClampColor, isCallValid, context, target, clamp);
    }
}

void GL_APIENTRY ClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
    EVENT("(GLenum buffer = %s, GLint drawbuffer = %d, GLfloat depth = %f, GLint stencil = %d)",
          GLenumToString(GLenumGroup::Buffer, buffer), drawbuffer, depth, stencil);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateClearBufferfi(context, buffer, drawbuffer, depth, stencil));
        if (isCallValid)
        {
            context->clearBufferfi(buffer, drawbuffer, depth, stencil);
        }
        ANGLE_CAPTURE(ClearBufferfi, isCallValid, context, buffer, drawbuffer, depth, stencil);
    }
}

void GL_APIENTRY ClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
    EVENT("(GLenum buffer = %s, GLint drawbuffer = %d, const GLfloat *value = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::Buffer, buffer), drawbuffer, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateClearBufferfv(context, buffer, drawbuffer, value));
        if (isCallValid)
        {
            context->clearBufferfv(buffer, drawbuffer, value);
        }
        ANGLE_CAPTURE(ClearBufferfv, isCallValid, context, buffer, drawbuffer, value);
    }
}

void GL_APIENTRY ClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
    EVENT("(GLenum buffer = %s, GLint drawbuffer = %d, const GLint *value = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::Buffer, buffer), drawbuffer, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateClearBufferiv(context, buffer, drawbuffer, value));
        if (isCallValid)
        {
            context->clearBufferiv(buffer, drawbuffer, value);
        }
        ANGLE_CAPTURE(ClearBufferiv, isCallValid, context, buffer, drawbuffer, value);
    }
}

void GL_APIENTRY ClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
    EVENT("(GLenum buffer = %s, GLint drawbuffer = %d, const GLuint *value = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::Buffer, buffer), drawbuffer, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateClearBufferuiv(context, buffer, drawbuffer, value));
        if (isCallValid)
        {
            context->clearBufferuiv(buffer, drawbuffer, value);
        }
        ANGLE_CAPTURE(ClearBufferuiv, isCallValid, context, buffer, drawbuffer, value);
    }
}

void GL_APIENTRY ColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
    EVENT(
        "(GLuint index = %u, GLboolean r = %s, GLboolean g = %s, GLboolean b = %s, GLboolean a = "
        "%s)",
        index, GLbooleanToString(r), GLbooleanToString(g), GLbooleanToString(b),
        GLbooleanToString(a));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateColorMaski(context, index, r, g, b, a));
        if (isCallValid)
        {
            context->colorMaski(index, r, g, b, a);
        }
        ANGLE_CAPTURE(ColorMaski, isCallValid, context, index, r, g, b, a);
    }
}

void GL_APIENTRY DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
    EVENT("(GLsizei n = %d, const GLuint *framebuffers = 0x%016" PRIxPTR ")", n,
          (uintptr_t)framebuffers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateDeleteFramebuffers(context, n, framebuffers));
        if (isCallValid)
        {
            context->deleteFramebuffers(n, framebuffers);
        }
        ANGLE_CAPTURE(DeleteFramebuffers, isCallValid, context, n, framebuffers);
    }
}

void GL_APIENTRY DeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
    EVENT("(GLsizei n = %d, const GLuint *renderbuffers = 0x%016" PRIxPTR ")", n,
          (uintptr_t)renderbuffers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        const RenderbufferID *renderbuffersPacked = FromGL<const RenderbufferID *>(renderbuffers);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateDeleteRenderbuffers(context, n, renderbuffersPacked));
        if (isCallValid)
        {
            context->deleteRenderbuffers(n, renderbuffersPacked);
        }
        ANGLE_CAPTURE(DeleteRenderbuffers, isCallValid, context, n, renderbuffersPacked);
    }
}

void GL_APIENTRY DeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
    EVENT("(GLsizei n = %d, const GLuint *arrays = 0x%016" PRIxPTR ")", n, (uintptr_t)arrays);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateDeleteVertexArrays(context, n, arrays));
        if (isCallValid)
        {
            context->deleteVertexArrays(n, arrays);
        }
        ANGLE_CAPTURE(DeleteVertexArrays, isCallValid, context, n, arrays);
    }
}

void GL_APIENTRY Disablei(GLenum target, GLuint index)
{
    EVENT("(GLenum target = %s, GLuint index = %u)", GLenumToString(GLenumGroup::EnableCap, target),
          index);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateDisablei(context, target, index));
        if (isCallValid)
        {
            context->disablei(target, index);
        }
        ANGLE_CAPTURE(Disablei, isCallValid, context, target, index);
    }
}

void GL_APIENTRY Enablei(GLenum target, GLuint index)
{
    EVENT("(GLenum target = %s, GLuint index = %u)", GLenumToString(GLenumGroup::EnableCap, target),
          index);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateEnablei(context, target, index));
        if (isCallValid)
        {
            context->enablei(target, index);
        }
        ANGLE_CAPTURE(Enablei, isCallValid, context, target, index);
    }
}

void GL_APIENTRY EndConditionalRender()
{
    EVENT("()");

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateEndConditionalRender(context));
        if (isCallValid)
        {
            context->endConditionalRender();
        }
        ANGLE_CAPTURE(EndConditionalRender, isCallValid, context);
    }
}

void GL_APIENTRY EndTransformFeedback()
{
    EVENT("()");

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateEndTransformFeedback(context));
        if (isCallValid)
        {
            context->endTransformFeedback();
        }
        ANGLE_CAPTURE(EndTransformFeedback, isCallValid, context);
    }
}

void GL_APIENTRY FlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
    EVENT("(GLenum target = %s, GLintptr offset = %llu, GLsizeiptr length = %llu)",
          GLenumToString(GLenumGroup::BufferTargetARB, target),
          static_cast<unsigned long long>(offset), static_cast<unsigned long long>(length));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        BufferBinding targetPacked                    = FromGL<BufferBinding>(target);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateFlushMappedBufferRange(context, targetPacked, offset, length));
        if (isCallValid)
        {
            context->flushMappedBufferRange(targetPacked, offset, length);
        }
        ANGLE_CAPTURE(FlushMappedBufferRange, isCallValid, context, targetPacked, offset, length);
    }
}

void GL_APIENTRY FramebufferRenderbuffer(GLenum target,
                                         GLenum attachment,
                                         GLenum renderbuffertarget,
                                         GLuint renderbuffer)
{
    EVENT(
        "(GLenum target = %s, GLenum attachment = %s, GLenum renderbuffertarget = %s, GLuint "
        "renderbuffer = %u)",
        GLenumToString(GLenumGroup::FramebufferTarget, target),
        GLenumToString(GLenumGroup::FramebufferAttachment, attachment),
        GLenumToString(GLenumGroup::RenderbufferTarget, renderbuffertarget), renderbuffer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        RenderbufferID renderbufferPacked             = FromGL<RenderbufferID>(renderbuffer);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateFramebufferRenderbuffer(context, target, attachment, renderbuffertarget,
                                             renderbufferPacked));
        if (isCallValid)
        {
            context->framebufferRenderbuffer(target, attachment, renderbuffertarget,
                                             renderbufferPacked);
        }
        ANGLE_CAPTURE(FramebufferRenderbuffer, isCallValid, context, target, attachment,
                      renderbuffertarget, renderbufferPacked);
    }
}

void GL_APIENTRY FramebufferTexture1D(GLenum target,
                                      GLenum attachment,
                                      GLenum textarget,
                                      GLuint texture,
                                      GLint level)
{
    EVENT(
        "(GLenum target = %s, GLenum attachment = %s, GLenum textarget = %s, GLuint texture = %u, "
        "GLint level = %d)",
        GLenumToString(GLenumGroup::FramebufferTarget, target),
        GLenumToString(GLenumGroup::FramebufferAttachment, attachment),
        GLenumToString(GLenumGroup::TextureTarget, textarget), texture, level);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureTarget textargetPacked                 = FromGL<TextureTarget>(textarget);
        TextureID texturePacked                       = FromGL<TextureID>(texture);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateFramebufferTexture1D(context, target, attachment,
                                                         textargetPacked, texturePacked, level));
        if (isCallValid)
        {
            context->framebufferTexture1D(target, attachment, textargetPacked, texturePacked,
                                          level);
        }
        ANGLE_CAPTURE(FramebufferTexture1D, isCallValid, context, target, attachment,
                      textargetPacked, texturePacked, level);
    }
}

void GL_APIENTRY FramebufferTexture2D(GLenum target,
                                      GLenum attachment,
                                      GLenum textarget,
                                      GLuint texture,
                                      GLint level)
{
    EVENT(
        "(GLenum target = %s, GLenum attachment = %s, GLenum textarget = %s, GLuint texture = %u, "
        "GLint level = %d)",
        GLenumToString(GLenumGroup::FramebufferTarget, target),
        GLenumToString(GLenumGroup::FramebufferAttachment, attachment),
        GLenumToString(GLenumGroup::TextureTarget, textarget), texture, level);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureTarget textargetPacked                 = FromGL<TextureTarget>(textarget);
        TextureID texturePacked                       = FromGL<TextureID>(texture);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateFramebufferTexture2D(context, target, attachment,
                                                         textargetPacked, texturePacked, level));
        if (isCallValid)
        {
            context->framebufferTexture2D(target, attachment, textargetPacked, texturePacked,
                                          level);
        }
        ANGLE_CAPTURE(FramebufferTexture2D, isCallValid, context, target, attachment,
                      textargetPacked, texturePacked, level);
    }
}

void GL_APIENTRY FramebufferTexture3D(GLenum target,
                                      GLenum attachment,
                                      GLenum textarget,
                                      GLuint texture,
                                      GLint level,
                                      GLint zoffset)
{
    EVENT(
        "(GLenum target = %s, GLenum attachment = %s, GLenum textarget = %s, GLuint texture = %u, "
        "GLint level = %d, GLint zoffset = %d)",
        GLenumToString(GLenumGroup::FramebufferTarget, target),
        GLenumToString(GLenumGroup::FramebufferAttachment, attachment),
        GLenumToString(GLenumGroup::TextureTarget, textarget), texture, level, zoffset);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureTarget textargetPacked                 = FromGL<TextureTarget>(textarget);
        TextureID texturePacked                       = FromGL<TextureID>(texture);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateFramebufferTexture3D(context, target, attachment, textargetPacked,
                                          texturePacked, level, zoffset));
        if (isCallValid)
        {
            context->framebufferTexture3D(target, attachment, textargetPacked, texturePacked, level,
                                          zoffset);
        }
        ANGLE_CAPTURE(FramebufferTexture3D, isCallValid, context, target, attachment,
                      textargetPacked, texturePacked, level, zoffset);
    }
}

void GL_APIENTRY
FramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
    EVENT(
        "(GLenum target = %s, GLenum attachment = %s, GLuint texture = %u, GLint level = %d, GLint "
        "layer = %d)",
        GLenumToString(GLenumGroup::FramebufferTarget, target),
        GLenumToString(GLenumGroup::FramebufferAttachment, attachment), texture, level, layer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureID texturePacked                       = FromGL<TextureID>(texture);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateFramebufferTextureLayer(context, target, attachment,
                                                            texturePacked, level, layer));
        if (isCallValid)
        {
            context->framebufferTextureLayer(target, attachment, texturePacked, level, layer);
        }
        ANGLE_CAPTURE(FramebufferTextureLayer, isCallValid, context, target, attachment,
                      texturePacked, level, layer);
    }
}

void GL_APIENTRY GenFramebuffers(GLsizei n, GLuint *framebuffers)
{
    EVENT("(GLsizei n = %d, GLuint *framebuffers = 0x%016" PRIxPTR ")", n, (uintptr_t)framebuffers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGenFramebuffers(context, n, framebuffers));
        if (isCallValid)
        {
            context->genFramebuffers(n, framebuffers);
        }
        ANGLE_CAPTURE(GenFramebuffers, isCallValid, context, n, framebuffers);
    }
}

void GL_APIENTRY GenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
    EVENT("(GLsizei n = %d, GLuint *renderbuffers = 0x%016" PRIxPTR ")", n,
          (uintptr_t)renderbuffers);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        RenderbufferID *renderbuffersPacked           = FromGL<RenderbufferID *>(renderbuffers);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGenRenderbuffers(context, n, renderbuffersPacked));
        if (isCallValid)
        {
            context->genRenderbuffers(n, renderbuffersPacked);
        }
        ANGLE_CAPTURE(GenRenderbuffers, isCallValid, context, n, renderbuffersPacked);
    }
}

void GL_APIENTRY GenVertexArrays(GLsizei n, GLuint *arrays)
{
    EVENT("(GLsizei n = %d, GLuint *arrays = 0x%016" PRIxPTR ")", n, (uintptr_t)arrays);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGenVertexArrays(context, n, arrays));
        if (isCallValid)
        {
            context->genVertexArrays(n, arrays);
        }
        ANGLE_CAPTURE(GenVertexArrays, isCallValid, context, n, arrays);
    }
}

void GL_APIENTRY GenerateMipmap(GLenum target)
{
    EVENT("(GLenum target = %s)", GLenumToString(GLenumGroup::TextureTarget, target));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureType targetPacked                      = FromGL<TextureType>(target);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGenerateMipmap(context, targetPacked));
        if (isCallValid)
        {
            context->generateMipmap(targetPacked);
        }
        ANGLE_CAPTURE(GenerateMipmap, isCallValid, context, targetPacked);
    }
}

void GL_APIENTRY GetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
    EVENT("(GLenum target = %s, GLuint index = %u, GLboolean *data = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::BufferTargetARB, target), index, (uintptr_t)data);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetBooleani_v(context, target, index, data));
        if (isCallValid)
        {
            context->getBooleani_v(target, index, data);
        }
        ANGLE_CAPTURE(GetBooleani_v, isCallValid, context, target, index, data);
    }
}

GLint GL_APIENTRY GetFragDataLocation(GLuint program, const GLchar *name)
{
    EVENT("(GLuint program = %u, const GLchar *name = 0x%016" PRIxPTR ")", program,
          (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    GLint returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetFragDataLocation(context, program, name));
        if (isCallValid)
        {
            returnValue = context->getFragDataLocation(program, name);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::GetFragDataLocation, GLint>();
        }
        ANGLE_CAPTURE(GetFragDataLocation, isCallValid, context, program, name, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::GetFragDataLocation, GLint>();
    }
    return returnValue;
}

void GL_APIENTRY GetFramebufferAttachmentParameteriv(GLenum target,
                                                     GLenum attachment,
                                                     GLenum pname,
                                                     GLint *params)
{
    EVENT(
        "(GLenum target = %s, GLenum attachment = %s, GLenum pname = %s, GLint *params = "
        "0x%016" PRIxPTR ")",
        GLenumToString(GLenumGroup::FramebufferTarget, target),
        GLenumToString(GLenumGroup::FramebufferAttachment, attachment),
        GLenumToString(GLenumGroup::FramebufferAttachmentParameterName, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetFramebufferAttachmentParameteriv(
                                              context, target, attachment, pname, params));
        if (isCallValid)
        {
            context->getFramebufferAttachmentParameteriv(target, attachment, pname, params);
        }
        ANGLE_CAPTURE(GetFramebufferAttachmentParameteriv, isCallValid, context, target, attachment,
                      pname, params);
    }
}

void GL_APIENTRY GetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
    EVENT("(GLenum target = %s, GLuint index = %u, GLint *data = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::TypeEnum, target), index, (uintptr_t)data);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateGetIntegeri_v(context, target, index, data));
        if (isCallValid)
        {
            context->getIntegeri_v(target, index, data);
        }
        ANGLE_CAPTURE(GetIntegeri_v, isCallValid, context, target, index, data);
    }
}

void GL_APIENTRY GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
    EVENT("(GLenum target = %s, GLenum pname = %s, GLint *params = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::RenderbufferTarget, target),
          GLenumToString(GLenumGroup::RenderbufferParameterName, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetRenderbufferParameteriv(context, target, pname, params));
        if (isCallValid)
        {
            context->getRenderbufferParameteriv(target, pname, params);
        }
        ANGLE_CAPTURE(GetRenderbufferParameteriv, isCallValid, context, target, pname, params);
    }
}

const GLubyte *GL_APIENTRY GetStringi(GLenum name, GLuint index)
{
    EVENT("(GLenum name = %s, GLuint index = %u)", GLenumToString(GLenumGroup::StringName, name),
          index);

    Context *context = GetValidGlobalContext();
    const GLubyte *returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateGetStringi(context, name, index));
        if (isCallValid)
        {
            returnValue = context->getStringi(name, index);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::GetStringi, const GLubyte *>();
        }
        ANGLE_CAPTURE(GetStringi, isCallValid, context, name, index, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::GetStringi, const GLubyte *>();
    }
    return returnValue;
}

void GL_APIENTRY GetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
    EVENT("(GLenum target = %s, GLenum pname = %s, GLint *params = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::TextureTarget, target),
          GLenumToString(GLenumGroup::GetTextureParameter, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureType targetPacked                      = FromGL<TextureType>(target);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetTexParameterIiv(context, targetPacked, pname, params));
        if (isCallValid)
        {
            context->getTexParameterIiv(targetPacked, pname, params);
        }
        ANGLE_CAPTURE(GetTexParameterIiv, isCallValid, context, targetPacked, pname, params);
    }
}

void GL_APIENTRY GetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
    EVENT("(GLenum target = %s, GLenum pname = %s, GLuint *params = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::TextureTarget, target),
          GLenumToString(GLenumGroup::GetTextureParameter, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureType targetPacked                      = FromGL<TextureType>(target);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetTexParameterIuiv(context, targetPacked, pname, params));
        if (isCallValid)
        {
            context->getTexParameterIuiv(targetPacked, pname, params);
        }
        ANGLE_CAPTURE(GetTexParameterIuiv, isCallValid, context, targetPacked, pname, params);
    }
}

void GL_APIENTRY GetTransformFeedbackVarying(GLuint program,
                                             GLuint index,
                                             GLsizei bufSize,
                                             GLsizei *length,
                                             GLsizei *size,
                                             GLenum *type,
                                             GLchar *name)
{
    EVENT(
        "(GLuint program = %u, GLuint index = %u, GLsizei bufSize = %d, GLsizei *length = "
        "0x%016" PRIxPTR ", GLsizei *size = 0x%016" PRIxPTR ", GLenum *type = 0x%016" PRIxPTR
        ", GLchar *name = 0x%016" PRIxPTR ")",
        program, index, bufSize, (uintptr_t)length, (uintptr_t)size, (uintptr_t)type,
        (uintptr_t)name);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetTransformFeedbackVarying(context, program, index, bufSize,
                                                                length, size, type, name));
        if (isCallValid)
        {
            context->getTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
        }
        ANGLE_CAPTURE(GetTransformFeedbackVarying, isCallValid, context, program, index, bufSize,
                      length, size, type, name);
    }
}

void GL_APIENTRY GetUniformuiv(GLuint program, GLint location, GLuint *params)
{
    EVENT("(GLuint program = %u, GLint location = %d, GLuint *params = 0x%016" PRIxPTR ")", program,
          location, (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetUniformuiv(context, program, location, params));
        if (isCallValid)
        {
            context->getUniformuiv(program, location, params);
        }
        ANGLE_CAPTURE(GetUniformuiv, isCallValid, context, program, location, params);
    }
}

void GL_APIENTRY GetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
    EVENT("(GLuint index = %u, GLenum pname = %s, GLint *params = 0x%016" PRIxPTR ")", index,
          GLenumToString(GLenumGroup::VertexAttribEnum, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetVertexAttribIiv(context, index, pname, params));
        if (isCallValid)
        {
            context->getVertexAttribIiv(index, pname, params);
        }
        ANGLE_CAPTURE(GetVertexAttribIiv, isCallValid, context, index, pname, params);
    }
}

void GL_APIENTRY GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
    EVENT("(GLuint index = %u, GLenum pname = %s, GLuint *params = 0x%016" PRIxPTR ")", index,
          GLenumToString(GLenumGroup::VertexAttribEnum, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateGetVertexAttribIuiv(context, index, pname, params));
        if (isCallValid)
        {
            context->getVertexAttribIuiv(index, pname, params);
        }
        ANGLE_CAPTURE(GetVertexAttribIuiv, isCallValid, context, index, pname, params);
    }
}

GLboolean GL_APIENTRY IsEnabledi(GLenum target, GLuint index)
{
    EVENT("(GLenum target = %s, GLuint index = %u)", GLenumToString(GLenumGroup::EnableCap, target),
          index);

    Context *context = GetValidGlobalContext();
    GLboolean returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateIsEnabledi(context, target, index));
        if (isCallValid)
        {
            returnValue = context->isEnabledi(target, index);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::IsEnabledi, GLboolean>();
        }
        ANGLE_CAPTURE(IsEnabledi, isCallValid, context, target, index, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::IsEnabledi, GLboolean>();
    }
    return returnValue;
}

GLboolean GL_APIENTRY IsFramebuffer(GLuint framebuffer)
{
    EVENT("(GLuint framebuffer = %u)", framebuffer);

    Context *context = GetValidGlobalContext();
    GLboolean returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateIsFramebuffer(context, framebuffer));
        if (isCallValid)
        {
            returnValue = context->isFramebuffer(framebuffer);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::IsFramebuffer, GLboolean>();
        }
        ANGLE_CAPTURE(IsFramebuffer, isCallValid, context, framebuffer, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::IsFramebuffer, GLboolean>();
    }
    return returnValue;
}

GLboolean GL_APIENTRY IsRenderbuffer(GLuint renderbuffer)
{
    EVENT("(GLuint renderbuffer = %u)", renderbuffer);

    Context *context = GetValidGlobalContext();
    GLboolean returnValue;
    if (context)
    {
        RenderbufferID renderbufferPacked             = FromGL<RenderbufferID>(renderbuffer);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateIsRenderbuffer(context, renderbufferPacked));
        if (isCallValid)
        {
            returnValue = context->isRenderbuffer(renderbufferPacked);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::IsRenderbuffer, GLboolean>();
        }
        ANGLE_CAPTURE(IsRenderbuffer, isCallValid, context, renderbufferPacked, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::IsRenderbuffer, GLboolean>();
    }
    return returnValue;
}

GLboolean GL_APIENTRY IsVertexArray(GLuint array)
{
    EVENT("(GLuint array = %u)", array);

    Context *context = GetValidGlobalContext();
    GLboolean returnValue;
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateIsVertexArray(context, array));
        if (isCallValid)
        {
            returnValue = context->isVertexArray(array);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::IsVertexArray, GLboolean>();
        }
        ANGLE_CAPTURE(IsVertexArray, isCallValid, context, array, returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::IsVertexArray, GLboolean>();
    }
    return returnValue;
}

void *GL_APIENTRY MapBufferRange(GLenum target,
                                 GLintptr offset,
                                 GLsizeiptr length,
                                 GLbitfield access)
{
    EVENT(
        "(GLenum target = %s, GLintptr offset = %llu, GLsizeiptr length = %llu, GLbitfield access "
        "= %s)",
        GLenumToString(GLenumGroup::BufferTargetARB, target),
        static_cast<unsigned long long>(offset), static_cast<unsigned long long>(length),
        GLbitfieldToString(GLenumGroup::BufferAccessMask, access).c_str());

    Context *context = GetValidGlobalContext();
    void *returnValue;
    if (context)
    {
        BufferBinding targetPacked                    = FromGL<BufferBinding>(target);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateMapBufferRange(context, targetPacked, offset, length, access));
        if (isCallValid)
        {
            returnValue = context->mapBufferRange(targetPacked, offset, length, access);
        }
        else
        {
            returnValue = GetDefaultReturnValue<EntryPoint::MapBufferRange, void *>();
        }
        ANGLE_CAPTURE(MapBufferRange, isCallValid, context, targetPacked, offset, length, access,
                      returnValue);
    }
    else
    {
        returnValue = GetDefaultReturnValue<EntryPoint::MapBufferRange, void *>();
    }
    return returnValue;
}

void GL_APIENTRY RenderbufferStorage(GLenum target,
                                     GLenum internalformat,
                                     GLsizei width,
                                     GLsizei height)
{
    EVENT(
        "(GLenum target = %s, GLenum internalformat = %s, GLsizei width = %d, GLsizei height = %d)",
        GLenumToString(GLenumGroup::RenderbufferTarget, target),
        GLenumToString(GLenumGroup::InternalFormat, internalformat), width, height);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateRenderbufferStorage(context, target, internalformat, width, height));
        if (isCallValid)
        {
            context->renderbufferStorage(target, internalformat, width, height);
        }
        ANGLE_CAPTURE(RenderbufferStorage, isCallValid, context, target, internalformat, width,
                      height);
    }
}

void GL_APIENTRY RenderbufferStorageMultisample(GLenum target,
                                                GLsizei samples,
                                                GLenum internalformat,
                                                GLsizei width,
                                                GLsizei height)
{
    EVENT(
        "(GLenum target = %s, GLsizei samples = %d, GLenum internalformat = %s, GLsizei width = "
        "%d, GLsizei height = %d)",
        GLenumToString(GLenumGroup::RenderbufferTarget, target), samples,
        GLenumToString(GLenumGroup::InternalFormat, internalformat), width, height);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateRenderbufferStorageMultisample(context, target, samples,
                                                                   internalformat, width, height));
        if (isCallValid)
        {
            context->renderbufferStorageMultisample(target, samples, internalformat, width, height);
        }
        ANGLE_CAPTURE(RenderbufferStorageMultisample, isCallValid, context, target, samples,
                      internalformat, width, height);
    }
}

void GL_APIENTRY TexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
    EVENT("(GLenum target = %s, GLenum pname = %s, const GLint *params = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::TextureTarget, target),
          GLenumToString(GLenumGroup::TextureParameterName, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureType targetPacked                      = FromGL<TextureType>(target);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateTexParameterIiv(context, targetPacked, pname, params));
        if (isCallValid)
        {
            context->texParameterIiv(targetPacked, pname, params);
        }
        ANGLE_CAPTURE(TexParameterIiv, isCallValid, context, targetPacked, pname, params);
    }
}

void GL_APIENTRY TexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
    EVENT("(GLenum target = %s, GLenum pname = %s, const GLuint *params = 0x%016" PRIxPTR ")",
          GLenumToString(GLenumGroup::TextureTarget, target),
          GLenumToString(GLenumGroup::TextureParameterName, pname), (uintptr_t)params);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        TextureType targetPacked                      = FromGL<TextureType>(target);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid                              = (context->skipValidation() ||
                            ValidateTexParameterIuiv(context, targetPacked, pname, params));
        if (isCallValid)
        {
            context->texParameterIuiv(targetPacked, pname, params);
        }
        ANGLE_CAPTURE(TexParameterIuiv, isCallValid, context, targetPacked, pname, params);
    }
}

void GL_APIENTRY TransformFeedbackVaryings(GLuint program,
                                           GLsizei count,
                                           const GLchar *const *varyings,
                                           GLenum bufferMode)
{
    EVENT("(GLuint program = %u, GLsizei count = %d, const GLchar *const*varyings = 0x%016" PRIxPTR
          ", GLenum bufferMode = %s)",
          program, count, (uintptr_t)varyings,
          GLenumToString(GLenumGroup::DefaultGroup, bufferMode));

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateTransformFeedbackVaryings(context, program, count, varyings, bufferMode));
        if (isCallValid)
        {
            context->transformFeedbackVaryings(program, count, varyings, bufferMode);
        }
        ANGLE_CAPTURE(TransformFeedbackVaryings, isCallValid, context, program, count, varyings,
                      bufferMode);
    }
}

void GL_APIENTRY Uniform1ui(GLint location, GLuint v0)
{
    EVENT("(GLint location = %d, GLuint v0 = %u)", location, v0);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid = (context->skipValidation() || ValidateUniform1ui(context, location, v0));
        if (isCallValid)
        {
            context->uniform1ui(location, v0);
        }
        ANGLE_CAPTURE(Uniform1ui, isCallValid, context, location, v0);
    }
}

void GL_APIENTRY Uniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLuint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform1uiv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform1uiv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform1uiv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform2ui(GLint location, GLuint v0, GLuint v1)
{
    EVENT("(GLint location = %d, GLuint v0 = %u, GLuint v1 = %u)", location, v0, v1);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2ui(context, location, v0, v1));
        if (isCallValid)
        {
            context->uniform2ui(location, v0, v1);
        }
        ANGLE_CAPTURE(Uniform2ui, isCallValid, context, location, v0, v1);
    }
}

void GL_APIENTRY Uniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLuint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform2uiv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform2uiv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform2uiv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
    EVENT("(GLint location = %d, GLuint v0 = %u, GLuint v1 = %u, GLuint v2 = %u)", location, v0, v1,
          v2);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3ui(context, location, v0, v1, v2));
        if (isCallValid)
        {
            context->uniform3ui(location, v0, v1, v2);
        }
        ANGLE_CAPTURE(Uniform3ui, isCallValid, context, location, v0, v1, v2);
    }
}

void GL_APIENTRY Uniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLuint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform3uiv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform3uiv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform3uiv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY Uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
    EVENT("(GLint location = %d, GLuint v0 = %u, GLuint v1 = %u, GLuint v2 = %u, GLuint v3 = %u)",
          location, v0, v1, v2, v3);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4ui(context, location, v0, v1, v2, v3));
        if (isCallValid)
        {
            context->uniform4ui(location, v0, v1, v2, v3);
        }
        ANGLE_CAPTURE(Uniform4ui, isCallValid, context, location, v0, v1, v2, v3);
    }
}

void GL_APIENTRY Uniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
    EVENT("(GLint location = %d, GLsizei count = %d, const GLuint *value = 0x%016" PRIxPTR ")",
          location, count, (uintptr_t)value);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateUniform4uiv(context, location, count, value));
        if (isCallValid)
        {
            context->uniform4uiv(location, count, value);
        }
        ANGLE_CAPTURE(Uniform4uiv, isCallValid, context, location, count, value);
    }
}

void GL_APIENTRY VertexAttribI1i(GLuint index, GLint x)
{
    EVENT("(GLuint index = %u, GLint x = %d)", index, x);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI1i(context, index, x));
        if (isCallValid)
        {
            context->vertexAttribI1i(index, x);
        }
        ANGLE_CAPTURE(VertexAttribI1i, isCallValid, context, index, x);
    }
}

void GL_APIENTRY VertexAttribI1iv(GLuint index, const GLint *v)
{
    EVENT("(GLuint index = %u, const GLint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI1iv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI1iv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI1iv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI1ui(GLuint index, GLuint x)
{
    EVENT("(GLuint index = %u, GLuint x = %u)", index, x);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI1ui(context, index, x));
        if (isCallValid)
        {
            context->vertexAttribI1ui(index, x);
        }
        ANGLE_CAPTURE(VertexAttribI1ui, isCallValid, context, index, x);
    }
}

void GL_APIENTRY VertexAttribI1uiv(GLuint index, const GLuint *v)
{
    EVENT("(GLuint index = %u, const GLuint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI1uiv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI1uiv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI1uiv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI2i(GLuint index, GLint x, GLint y)
{
    EVENT("(GLuint index = %u, GLint x = %d, GLint y = %d)", index, x, y);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI2i(context, index, x, y));
        if (isCallValid)
        {
            context->vertexAttribI2i(index, x, y);
        }
        ANGLE_CAPTURE(VertexAttribI2i, isCallValid, context, index, x, y);
    }
}

void GL_APIENTRY VertexAttribI2iv(GLuint index, const GLint *v)
{
    EVENT("(GLuint index = %u, const GLint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI2iv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI2iv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI2iv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
    EVENT("(GLuint index = %u, GLuint x = %u, GLuint y = %u)", index, x, y);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI2ui(context, index, x, y));
        if (isCallValid)
        {
            context->vertexAttribI2ui(index, x, y);
        }
        ANGLE_CAPTURE(VertexAttribI2ui, isCallValid, context, index, x, y);
    }
}

void GL_APIENTRY VertexAttribI2uiv(GLuint index, const GLuint *v)
{
    EVENT("(GLuint index = %u, const GLuint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI2uiv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI2uiv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI2uiv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
    EVENT("(GLuint index = %u, GLint x = %d, GLint y = %d, GLint z = %d)", index, x, y, z);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI3i(context, index, x, y, z));
        if (isCallValid)
        {
            context->vertexAttribI3i(index, x, y, z);
        }
        ANGLE_CAPTURE(VertexAttribI3i, isCallValid, context, index, x, y, z);
    }
}

void GL_APIENTRY VertexAttribI3iv(GLuint index, const GLint *v)
{
    EVENT("(GLuint index = %u, const GLint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI3iv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI3iv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI3iv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
    EVENT("(GLuint index = %u, GLuint x = %u, GLuint y = %u, GLuint z = %u)", index, x, y, z);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI3ui(context, index, x, y, z));
        if (isCallValid)
        {
            context->vertexAttribI3ui(index, x, y, z);
        }
        ANGLE_CAPTURE(VertexAttribI3ui, isCallValid, context, index, x, y, z);
    }
}

void GL_APIENTRY VertexAttribI3uiv(GLuint index, const GLuint *v)
{
    EVENT("(GLuint index = %u, const GLuint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI3uiv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI3uiv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI3uiv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI4bv(GLuint index, const GLbyte *v)
{
    EVENT("(GLuint index = %u, const GLbyte *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4bv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI4bv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI4bv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
    EVENT("(GLuint index = %u, GLint x = %d, GLint y = %d, GLint z = %d, GLint w = %d)", index, x,
          y, z, w);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4i(context, index, x, y, z, w));
        if (isCallValid)
        {
            context->vertexAttribI4i(index, x, y, z, w);
        }
        ANGLE_CAPTURE(VertexAttribI4i, isCallValid, context, index, x, y, z, w);
    }
}

void GL_APIENTRY VertexAttribI4iv(GLuint index, const GLint *v)
{
    EVENT("(GLuint index = %u, const GLint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4iv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI4iv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI4iv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI4sv(GLuint index, const GLshort *v)
{
    EVENT("(GLuint index = %u, const GLshort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4sv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI4sv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI4sv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI4ubv(GLuint index, const GLubyte *v)
{
    EVENT("(GLuint index = %u, const GLubyte *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4ubv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI4ubv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI4ubv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
    EVENT("(GLuint index = %u, GLuint x = %u, GLuint y = %u, GLuint z = %u, GLuint w = %u)", index,
          x, y, z, w);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4ui(context, index, x, y, z, w));
        if (isCallValid)
        {
            context->vertexAttribI4ui(index, x, y, z, w);
        }
        ANGLE_CAPTURE(VertexAttribI4ui, isCallValid, context, index, x, y, z, w);
    }
}

void GL_APIENTRY VertexAttribI4uiv(GLuint index, const GLuint *v)
{
    EVENT("(GLuint index = %u, const GLuint *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4uiv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI4uiv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI4uiv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY VertexAttribI4usv(GLuint index, const GLushort *v)
{
    EVENT("(GLuint index = %u, const GLushort *v = 0x%016" PRIxPTR ")", index, (uintptr_t)v);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() || ValidateVertexAttribI4usv(context, index, v));
        if (isCallValid)
        {
            context->vertexAttribI4usv(index, v);
        }
        ANGLE_CAPTURE(VertexAttribI4usv, isCallValid, context, index, v);
    }
}

void GL_APIENTRY
VertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer)
{
    EVENT(
        "(GLuint index = %u, GLint size = %d, GLenum type = %s, GLsizei stride = %d, const void "
        "*pointer = 0x%016" PRIxPTR ")",
        index, size, GLenumToString(GLenumGroup::VertexAttribPointerType, type), stride,
        (uintptr_t)pointer);

    Context *context = GetValidGlobalContext();
    if (context)
    {
        VertexAttribType typePacked                   = FromGL<VertexAttribType>(type);
        std::unique_lock<std::mutex> shareContextLock = GetShareGroupLock(context);
        bool isCallValid =
            (context->skipValidation() ||
             ValidateVertexAttribIPointer(context, index, size, typePacked, stride, pointer));
        if (isCallValid)
        {
            context->vertexAttribIPointer(index, size, typePacked, stride, pointer);
        }
        ANGLE_CAPTURE(VertexAttribIPointer, isCallValid, context, index, size, typePacked, stride,
                      pointer);
    }
}
}  // namespace gl
